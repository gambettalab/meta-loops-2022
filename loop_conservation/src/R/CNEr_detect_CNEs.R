options(warn = 1)

# Read config file
config <- yaml::yaml.load_file("config/config.yml")

library(data.table)
library(CNEr)
library(GenomicRanges)
library(ggplot2)

assemblyDir <- "data/lastz/2bit"
axtDir <- "data/lastz/axt"

#
#  Extract annotated exons for the given genome
#

extract_exons <- function(genome)
{
  chromosomes <- strsplit(config$genomes[[genome]]$chromosomes, " ")[[1]]

  if ("exons" %in% names(config$genomes[[genome]]))
    exons <- rtracklayer::import(config$genomes[[genome]]$exons)
  else if ("gtf" %in% names(config$genomes[[genome]]))
  {
    gtf <- rtracklayer::import(config$genomes[[genome]]$gtf)
    exons <- gtf[gtf$type == "exon" & seqnames(gtf) %in% chromosomes]
  }
  else
    stop("no exons for genome ", genome)

  return(exons)
}

#
#  Detect conserved noncoding elements (CNEs) using "net" alignments in Axt format
#

detect_CNEs <- function(genome1, genome2, noncoding = TRUE)
{
  ## 2bit files generated by faToTwoBit
  assembly1 <- paste0("data/lastz/2bit/", genome1, ".2bit")
  assembly2 <- paste0("data/lastz/2bit/", genome2, ".2bit")

  ## axtNet files generated by CNEr
  axtFiles12 <- paste0(axtDir, "/", genome1, ".", genome2, ".net.axt")
  axtFiles21 <- paste0(axtDir, "/", genome2, ".", genome1, ".net.axt")

  # axt12 <- readAxt(axtFiles12, tAssemblyFn = assembly1, qAssemblyFn = assembly2)
  # axt21 <- readAxt(axtFiles21, tAssemblyFn = assembly2, qAssemblyFn = assembly1)

  ## Creating a CNE class
  cne12 <- CNE(assembly1Fn=assembly1, assembly2Fn=assembly2, axt12Fn=axtFiles12, axt21Fn=axtFiles21)
  # cne21 <- CNE(assembly1Fn=assembly2, assembly2Fn=assembly1, axt12Fn=axtFiles21, axt21Fn=axtFiles12)

  # ## Filtering out exons as undesired regions
  # bed1Fn <- file.path(system.file("extdata", package="CNEr"), "filter_regions.1.bed")
  # filter1 <- readBed(bed1Fn)

  ## Identification of conserved noncoding regions: scan the axt alignments for the regions, with minimal I identities over C columns, which do not overlap with annotated exons
  identities <- c(21L, 24L, 27L, 35L, 40L, 45L)
  windows <- c(30L, 30L, 30L, 50L, 50L, 50L)
  if (noncoding)
    cneList12 <- ceScan(x=cne12, tFilter=extract_exons(genome1), qFilter=extract_exons(genome2),
      window=windows, identity=identities)
  else
    cneList12 <- ceScan(x=cne12, window=windows, identity=identities)

  ## Merging overlapped elements
  cneMergedList12 <- lapply(cneList12, cneMerge)

  ## Realignment of CNEs to remove unannotated repetitive sequences
  cneFinalList12 <- lapply(cneMergedList12, blatCNE)

  if (noncoding)
    saveRDS(cneFinalList12, file = paste0("data/lastz/cneFinalList.", genome1, ".", genome2, ".Rds"))
  else
    saveRDS(cneFinalList12, file = paste0("data/lastz/ceFinalList.", genome1, ".", genome2, ".Rds"))
}


for (noncoding in c(FALSE, TRUE))
{
  detect_CNEs("D_mel", "D_vir", noncoding = noncoding)
  detect_CNEs("D_vir", "D_mel", noncoding = noncoding)
}

#
#  Helper function to properly annotate strand of merged CNEs
#

cneReannotateStrand <- function(cne)
{
  strand(first(cne@CNEFinal)) <- '*'
  strand(second(cne@CNEFinal)) <- '*'

  # overlap the final CNEs with the preliminary CNEs from axt file with assembly1 as reference
  ov12_first <- findOverlaps(first(cne@CNEFinal), first(cne@CNE12))
  ov12_second <- findOverlaps(second(cne@CNEFinal), second(cne@CNE12))
  ov12 <- intersect(ov12_first, ov12_second)
  strand12_dt <- data.table(query = queryHits(ov12), as.data.table(strand(cne@CNE12[subjectHits(ov12)])))

  # overlap the final CNEs with the preliminary CNEs from axt file with assembly2 as reference
  ov21_first <- findOverlaps(first(cne@CNEFinal), second(cne@CNE21))
  ov21_second <- findOverlaps(second(cne@CNEFinal), first(cne@CNE21))
  ov21 <- intersect(ov21_first, ov21_second)
  strand21_dt <- data.table(query = queryHits(ov21), as.data.table(strand(cne@CNE21[subjectHits(ov21)])))

  # take the unique strand, or '*' in case of conflicting annotations
  uniqueStrand <- function(v) if (length(unique(v)) == 1) v[1] else factor('*', levels(v))
  strand_dt <- rbind(strand12_dt, strand21_dt)[,
    list(first = uniqueStrand(first), second = uniqueStrand(second)), by = "query"]

  strand(first(cne@CNEFinal))[strand_dt$query] <- strand_dt$first
  strand(second(cne@CNEFinal))[strand_dt$query] <- strand_dt$second
  return(cne)
}

#
#  Helper function to chain merged CNEs
#

cneChain <- function(cne, max_distance = 10e3)
{
  cne <- sort(cne)
  elementMetadata(cne)$chain_id <- seq_along(cne)
  elementMetadata(cne)$chain_prev <- NA
  elementMetadata(cne)$chain_next <- NA
  elementMetadata(cne)$chaining_distance <- NA

  # identify candidate edges in the chain
  ov_first <- findOverlaps(first(cne), first(cne), maxgap = max_distance)
  ov_second <- findOverlaps(second(cne), second(cne), maxgap = max_distance)
  ov <- intersect(ov_first, ov_second)
  ov_dt <- data.table(query = queryHits(ov), subject = subjectHits(ov))
  ov_dt <- ov_dt[query < subject, ]

  # take only the candidate edges where the putative chaining order is concordant with CNEs' strands
  ov_dt[, query.first.start := start(first(cne))[query]]
  ov_dt[, query.first.end := end(first(cne))[query]]
  ov_dt[, query.second.start := start(second(cne))[query]]
  ov_dt[, query.second.end := end(second(cne))[query]]
  ov_dt[, query.second.strand := as.vector(strand(second(cne)))[query]]

  ov_dt[, subject.first.start := start(first(cne))[subject]]
  ov_dt[, subject.first.end := end(first(cne))[subject]]
  ov_dt[, subject.second.start := start(second(cne))[subject]]
  ov_dt[, subject.second.end := end(second(cne))[subject]]
  ov_dt[, subject.second.strand := as.vector(strand(second(cne)))[subject]]

  ov_dt[, concordant.forward := query.second.strand != '-' & subject.second.strand != '-'
    & ((query.first.end <= subject.first.start & query.second.end <= subject.second.start)
      | (subject.first.end <= query.first.start & subject.second.end <= query.second.start))]
  ov_dt[, concordant.reverse := query.second.strand != '+' & subject.second.strand != '+'
    & ((query.first.end <= subject.first.start & subject.second.end <= query.second.start)
      | (subject.first.end <= query.first.start & query.second.end <= subject.second.start))]
  ov_dt <- ov_dt[concordant.forward | concordant.reverse, ]

  # sort the candidate edges by distance
  ov_dt[, first.distance := distance(first(cne)[query], first(cne)[subject])]
  ov_dt[, second.distance := distance(second(cne)[query], second(cne)[subject])]
  ov_dt[, distance := pmax(first.distance, second.distance)]
  setkey(ov_dt, distance)

  nrow_prev <- Inf
  while (nrow(ov_dt) < nrow_prev)
  {
    message("cneChain: ", nrow(ov_dt), " candidate edges remained")
    nrow_prev <- nrow(ov_dt)

    # in this while() iteration, go only through a given number of rows from ov_dt
    nfirst <- min(nrow(ov_dt), 10e3)

    for (i in seq_len(nfirst))
    {
      query_id <- ov_dt$query[i]
      subject_id <- ov_dt$subject[i]
      query_chain_id <- elementMetadata(cne)$chain_id[query_id]
      subject_chain_id <- elementMetadata(cne)$chain_id[subject_id]

      # if the chain IDs differ for the two CNEs connected by the candidate edge,
      # then it might be possible to join the two chains
      if (query_chain_id != subject_chain_id &&
        is.na(elementMetadata(cne)$chain_next[query_id]) &&
        is.na(elementMetadata(cne)$chain_prev[subject_id]))
      {
        elementMetadata(cne)$chain_id[elementMetadata(cne)$chain_id == subject_chain_id] <- query_chain_id
        elementMetadata(cne)$chain_next[query_id] <- subject_id
        elementMetadata(cne)$chain_prev[subject_id] <- query_id
        elementMetadata(cne)$chaining_distance[query_id] <- ov_dt$distance[i]
      }
      # there is possibility that two CNEs are connected by the candidate edge, but one of them
      # is in the middle of the chain already, and cannot be joined; in such a case we proceed further
    }

    # remove candidate edges that were already processed
    ov_dt <- ov_dt[tail(seq_len(nrow(ov_dt)), -nfirst), ]

    # remove candidate edges that are already within the same chain
    ov_dt <- ov_dt[elementMetadata(cne)$chain_id[query] != elementMetadata(cne)$chain_id[subject], ]
  }

  # add chain order to the CNEs
  elementMetadata(cne)$chain_seq <- NA
  elementMetadata(cne)$chain_seq[is.na(elementMetadata(cne)$chain_prev)] <- 1L
  while (any(is.na(elementMetadata(cne)$chain_seq)))
  {
    sel <- !is.na(elementMetadata(cne)$chain_next)
    elementMetadata(cne)$chain_seq[elementMetadata(cne)$chain_next[sel]] <-
      elementMetadata(cne)$chain_seq[sel] + 1L
  }

  # sort the CNEs according to their chain order
  elementMetadata(cne)$chain_prev <- NULL
  elementMetadata(cne)$chain_next <- NULL
  cne <- cne[with(elementMetadata(cne), order(chain_id, chain_seq))]
  elementMetadata(cne)$chain_seq <- NULL

  # take only the chains containing at least two CNEs
  dt <- data.table(chain_id = elementMetadata(cne)$chain_id)
  allowed_chain_id <- dt[, list(.N), by = "chain_id"][N > 1, ]$chain_id
  cne <- cne[elementMetadata(cne)$chain_id %in% allowed_chain_id]

  return(cne)
}

#
#  Final annotated and chained CNEs
#

params <- list(D_vir = "40_50")

annotate_and_chain <- function(genome, other_genome, params, noncoding = TRUE)
{
  cneFinalList <- readRDS(paste0("data/lastz/", ifelse(noncoding, "cne", "ce"),
    "FinalList.", genome, ".", other_genome, ".Rds"))
  cneFinalList <- lapply(cneFinalList, cneReannotateStrand)
  cneFinal <- cneChain(cneFinalList[[params]]@CNEFinal)

  exons <- as.data.table(reduce(extract_exons(genome)))
  exons_other <- as.data.table(reduce(extract_exons(other_genome)))
  save(cneFinal, exons, exons_other, file = paste0("data/lastz/", ifelse(noncoding, "cne", "ce"),
    "FinalAnnotated.", genome, ".", other_genome, ".Rdata"))

  # save the alignments as .gff file for genome browser inspection as well
  cneFinal_gr <- first(cneFinal)
  elementMetadata(cneFinal_gr)$other <- elementMetadata(cneFinal)
  elementMetadata(cneFinal_gr)$other <- as.character(second(cneFinal))
  rtracklayer::export.gff3(cneFinal_gr, paste0("data/lastz/", ifelse(noncoding, "cne", "ce"),
    "FinalAnnotated.", genome, ".", other_genome, ".gff"))
}


for (noncoding in c(FALSE, TRUE))
{
  annotate_and_chain("D_mel", "D_vir", params = params[["D_vir"]], noncoding = noncoding)
  annotate_and_chain("D_vir", "D_mel", params = params[["D_vir"]], noncoding = noncoding)
}
